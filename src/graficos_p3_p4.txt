import kaggle
import zipfile
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt

# ==============================
# 1) Definir carpeta de trabajo
# ==============================
work_dir = r"C:\Users\Prestamo\Desktop\Yerlin\Curso_Python\proyecto-final\src"
os.makedirs(work_dir, exist_ok=True)

# Archivo ZIP y carpeta destino
zip_path = os.path.join(work_dir, "world-happiness.zip")
dest_path = os.path.join(work_dir, "world_happiness")
os.makedirs(dest_path, exist_ok=True)

# ==============================
# 2) Descargar dataset con Kaggle API
# ==============================
print("Descargando dataset desde Kaggle...")
os.system(f'kaggle datasets download -d unsdsn/world-happiness -p "{work_dir}"')

# ==============================
# 3) Extraer contenido del ZIP
# ==============================
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(dest_path)

print(f"Archivo descomprimido en '{dest_path}'")

# ==============================
# 4) Detectar y cargar CSV
# ==============================
files = os.listdir(dest_path)
print("Archivos extraídos:", files)

# Tomar el primer CSV que aparezca
csv_file = [f for f in files if f.endswith(".csv")][0]
csv_path = os.path.join(dest_path, csv_file)

df = pd.read_csv(csv_path)
print("Columnas en el dataset:", df.columns.tolist())

# ==============================
# 5) Identificar columnas clave
# ==============================
possible_corr = [c for c in df.columns if 'corrup' in c.lower() or 'corrupt' in c.lower()]
possible_score = [c for c in df.columns if 'ladder' in c.lower() or 'score' in c.lower() or 'happiness' in c.lower()]
possible_country = [c for c in df.columns if 'country' in c.lower()]

corruption_col = possible_corr[0]
score_col = possible_score[0]
country_col = possible_country[0]

# ==============================
# 6) Limpiar y seleccionar datos
# ==============================
df = df[[country_col, corruption_col, score_col]].dropna()

# ==============================
# 7) Agrupar por cuartiles de corrupción
# ==============================
df['corr_group'] = pd.qcut(
    df[corruption_col],
    q=4,
    labels=['Muy baja', 'Baja', 'Alta', 'Muy alta'],
    duplicates='drop'
)

grouped = df.groupby('corr_group')[score_col].agg(['mean','std','count']).reset_index()
print(grouped)

# ==============================
# 8) Gráfico de barras
# ==============================
x = np.arange(len(grouped))
means = grouped['mean']
stds = grouped['std']

plt.figure(figsize=(8,5))
plt.bar(x, means)
plt.errorbar(x, means, yerr=stds, fmt='none', capsize=5)
plt.xticks(x, grouped['corr_group'].astype(str))
plt.xlabel('Percepción de corrupción (cuartiles)')
plt.ylabel('Puntaje de felicidad promedio')
plt.title('Felicidad promedio por nivel de percepción de corrupción')
plt.tight_layout()
plt.show()

# ==============================
# 9) Correlación Pearson
# ==============================
try:
    from scipy.stats import pearsonr
    r, p = pearsonr(df[corruption_col], df[score_col])
    print(f"Pearson r = {r:.3f}, p = {p:.3e}")
except Exception:
    r = np.corrcoef(df[corruption_col], df[score_col])[0,1]
    print(f"scipy no disponible. Correlación aproximada r = {r:.3f}")